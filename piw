#!/usr/bin/env bash
#
# piw — start pi in an isolated git worktree
#
# Creates a fresh worktree from HEAD (or a given ref), runs pi inside it,
# and cleans up the worktree on exit. All pi arguments are forwarded.
#
# Usage:
#   ./piw                    # worktree from HEAD, detached
#   ./piw --ref main         # worktree from main branch
#   ./piw --branch fix-foo   # worktree on new branch fix-foo
#   ./piw -- -p "hello"      # everything after -- goes to pi
#
set -euo pipefail

# ── Parse our flags (before --), forward the rest to pi ──
REF="HEAD"
BRANCH=""
PI_ARGS=()

while [[ $# -gt 0 ]]; do
	case "$1" in
		--ref)    REF="$2"; shift 2 ;;
		--branch) BRANCH="$2"; shift 2 ;;
		--)       shift; PI_ARGS=("$@"); break ;;
		*)        PI_ARGS+=("$1"); shift ;;
	esac
done

# ── Resolve repo root ──
TOPLEVEL="$(git rev-parse --show-toplevel 2>/dev/null)" || {
	echo "error: not in a git repository" >&2
	exit 1
}
REPO_NAME="$(basename "$TOPLEVEL")"

# ── Create worktree ──
WORKTREE_BASE="/tmp/pi-worktrees/${REPO_NAME}"
WORKTREE_NAME="session-$(date +%s)-$(printf '%04x' $RANDOM)"
WORKTREE_PATH="${WORKTREE_BASE}/${WORKTREE_NAME}"
mkdir -p "$WORKTREE_BASE"

cleanup() {
	if [[ -d "$WORKTREE_PATH" ]]; then
		git -C "$TOPLEVEL" worktree remove --force "$WORKTREE_PATH" 2>/dev/null \
			|| { rm -rf "$WORKTREE_PATH"; git -C "$TOPLEVEL" worktree prune 2>/dev/null; } \
			|| true
	fi
}
trap cleanup EXIT INT TERM

if [[ -n "$BRANCH" ]]; then
	git -C "$TOPLEVEL" worktree add -b "$BRANCH" "$WORKTREE_PATH" "$REF"
else
	git -C "$TOPLEVEL" worktree add --detach "$WORKTREE_PATH" "$REF"
fi

echo "worktree: $WORKTREE_PATH"

# ── Run pi in the worktree ──
cd "$WORKTREE_PATH"
exec pi ${PI_ARGS[@]+"${PI_ARGS[@]}"}
